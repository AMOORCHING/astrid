"""
Vulnerability Scanner for NVD (National Vulnerability Database) Integration

This module provides comprehensive vulnerability scanning capabilities by:
- Integrating with NIST NVD API v2.0 for CVE data
- Mapping package dependencies to known vulnerabilities
- Filtering and prioritizing security findings
- Caching vulnerability data for performance
- Providing detailed vulnerability reports
"""

import asyncio
import logging
import os
import re
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import httpx
from cachetools import TTLCache
import json

from ..models import DependencyInfo
from ..utils.exceptions import (
    ExternalServiceError, 
    VulnerabilityServiceError,
    RateLimitError,
    ConfigurationError
)
from .dependency_parser import ParsedDependency, PackageEcosystem

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(str, Enum):
    """Vulnerability severity levels based on CVSS scores"""
    CRITICAL = "CRITICAL"    # 9.0-10.0
    HIGH = "HIGH"           # 7.0-8.9
    MEDIUM = "MEDIUM"       # 4.0-6.9
    LOW = "LOW"             # 0.1-3.9
    NONE = "NONE"           # 0.0
    UNKNOWN = "UNKNOWN"     # No CVSS score available


@dataclass
class VulnerabilityMatch:
    """Represents a vulnerability found in a dependency"""
    cve_id: str
    package_name: str
    package_version: str
    vulnerability_data: Any  # Will be the models.VulnerabilityData
    confidence_score: float  # 0.0-1.0 confidence in the match
    match_method: str       # How the vulnerability was matched
    affected_versions: List[str]
    patched_versions: List[str]


@dataclass
class NVDAPIResponse:
    """Structured response from NVD API"""
    cves: List[Dict[str, Any]]
    total_results: int
    results_per_page: int
    start_index: int
    format: str
    version: str
    timestamp: datetime


class NVDAPIClient:
    """
    Client for NIST National Vulnerability Database (NVD) API v2.0
    
    Features:
    - Rate limiting and request optimization
    - Response caching with TTL
    - API key authentication support
    - Comprehensive error handling
    - CVE search by keyword and CPE
    """
    
    def __init__(
        self,
        api_key: Optional[str] = None,
        base_url: str = "https://services.nvd.nist.gov/rest/json",
        timeout: float = 30.0,
        max_retries: int = 3,
        cache_ttl: int = 3600,  # 1 hour cache
        requests_per_second: float = 0.6  # NVD rate limit: 5 requests per 30 seconds without key
    ):
        """
        Initialize NVD API client
        
        Args:
            api_key: NVD API key (recommended for higher rate limits)
            base_url: NVD API base URL
            timeout: Request timeout in seconds
            max_retries: Maximum retry attempts
            cache_ttl: Cache time-to-live in seconds
            requests_per_second: Rate limiting (higher with API key)
        """
        self.api_key = api_key or os.getenv("NVD_API_KEY")
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.max_retries = max_retries
        
        # Rate limiting - NVD allows more requests with API key
        if self.api_key:
            self.requests_per_second = 50.0 / 30.0  # 50 requests per 30 seconds with key
        else:
            self.requests_per_second = requests_per_second
            logger.warning("No NVD API key provided - rate limits will be lower")
        
        # Setup HTTP client
        headers = {
            "User-Agent": "Caponier-Security-Scanner/1.0",
            "Accept": "application/json"
        }
        
        if self.api_key:
            headers["apiKey"] = self.api_key
            logger.info("NVD API client initialized with API key")
        
        self.client = httpx.AsyncClient(
            headers=headers,
            timeout=self.timeout,
            limits=httpx.Limits(max_keepalive_connections=5, max_connections=10)
        )
        
        # Response cache and rate limiting
        self.cache = TTLCache(maxsize=1000, ttl=cache_ttl)
        self.last_request_time = 0.0
        
        # Request statistics
        self.stats = {
            "requests_made": 0,
            "cache_hits": 0,
            "rate_limit_delays": 0,
            "errors": 0
        }
    
    async def __aenter__(self):
        """Async context manager entry"""
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        await self.close()
    
    async def close(self):
        """Close HTTP client"""
        await self.client.aclose()
    
    async def _rate_limit_delay(self):
        """Implement rate limiting delay"""
        if self.last_request_time == 0.0:
            self.last_request_time = asyncio.get_event_loop().time()
            return
        
        current_time = asyncio.get_event_loop().time()
        time_since_last = current_time - self.last_request_time
        min_interval = 1.0 / self.requests_per_second
        
        if time_since_last < min_interval:
            delay = min_interval - time_since_last
            logger.debug(f"Rate limiting: waiting {delay:.2f} seconds")
            self.stats["rate_limit_delays"] += 1
            await asyncio.sleep(delay)
        
        self.last_request_time = asyncio.get_event_loop().time()
    
    async def _make_request(
        self,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None,
        use_cache: bool = True
    ) -> Dict[str, Any]:
        """
        Make rate-limited request to NVD API
        
        Args:
            endpoint: API endpoint
            params: Query parameters
            use_cache: Whether to use cached responses
            
        Returns:
            JSON response data
        """
        # Check cache first
        cache_key = self._get_cache_key(endpoint, params) if use_cache else None
        if cache_key and cache_key in self.cache:
            self.stats["cache_hits"] += 1
            logger.debug(f"Cache hit for {endpoint}")
            return self.cache[cache_key]
        
        # Rate limiting
        await self._rate_limit_delay()
        
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        retry_count = 0
        
        while retry_count <= self.max_retries:
            try:
                self.stats["requests_made"] += 1
                logger.debug(f"Making NVD API request to {endpoint}")
                
                response = await self.client.get(url, params=params)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    # Cache successful responses
                    if cache_key:
                        self.cache[cache_key] = data
                    
                    return data
                
                elif response.status_code == 403:
                    raise VulnerabilityServiceError(
                        "NVD API access forbidden - check API key",
                        service="NVD API",
                        status_code=403
                    )
                
                elif response.status_code == 429:
                    # Rate limited
                    if retry_count < self.max_retries:
                        wait_time = (2 ** retry_count) * 60  # Exponential backoff in minutes
                        logger.warning(f"NVD API rate limited. Waiting {wait_time} seconds...")
                        await asyncio.sleep(wait_time)
                        retry_count += 1
                        continue
                    else:
                        raise RateLimitError(
                            "NVD API rate limit exceeded",
                            service="NVD API",
                            retry_after=3600
                        )
                
                elif response.status_code >= 500:
                    # Server error - retry
                    if retry_count < self.max_retries:
                        wait_time = 2 ** retry_count  # Exponential backoff
                        logger.warning(f"NVD API server error. Retrying in {wait_time} seconds...")
                        await asyncio.sleep(wait_time)
                        retry_count += 1
                        continue
                    else:
                        raise ExternalServiceError(
                            f"NVD API server error (HTTP {response.status_code})",
                            service="NVD API"
                        )
                
                else:
                    raise VulnerabilityServiceError(
                        f"NVD API request failed with status {response.status_code}",
                        service="NVD API",
                        status_code=response.status_code
                    )
                    
            except httpx.TimeoutException:
                if retry_count < self.max_retries:
                    wait_time = 2 ** retry_count
                    logger.warning(f"NVD API timeout. Retrying in {wait_time} seconds...")
                    await asyncio.sleep(wait_time)
                    retry_count += 1
                    continue
                else:
                    raise ExternalServiceError(
                        "NVD API request timeout",
                        service="NVD API"
                    )
            
            except Exception as e:
                self.stats["errors"] += 1
                logger.error(f"NVD API request failed: {str(e)}")
                raise ExternalServiceError(
                    f"NVD API request failed: {str(e)}",
                    service="NVD API"
                )
    
    def _get_cache_key(self, endpoint: str, params: Optional[Dict] = None) -> str:
        """Generate cache key for request"""
        key_parts = [endpoint]
        if params:
            # Sort params for consistent cache keys
            sorted_params = sorted(params.items())
            key_parts.extend([f"{k}={v}" for k, v in sorted_params])
        return "|".join(key_parts)
    
    async def search_cves_by_keyword(
        self,
        keyword: str,
        results_per_page: int = 100,
        start_index: int = 0,
        last_mod_start_date: Optional[datetime] = None,
        last_mod_end_date: Optional[datetime] = None
    ) -> NVDAPIResponse:
        """
        Search CVEs by keyword
        
        Args:
            keyword: Search keyword (package name, vendor, etc.)
            results_per_page: Number of results per page (max 2000)
            start_index: Starting index for pagination
            last_mod_start_date: Filter by modification date (start)
            last_mod_end_date: Filter by modification date (end)
            
        Returns:
            NVD API response with CVE data
        """
        params = {
            "keywordSearch": keyword,
            "resultsPerPage": min(results_per_page, 2000),  # NVD max limit
            "startIndex": start_index
        }
        
        # Add date filters if provided
        if last_mod_start_date:
            params["lastModStartDate"] = last_mod_start_date.isoformat()
        if last_mod_end_date:
            params["lastModEndDate"] = last_mod_end_date.isoformat()
        
        response = await self._make_request("cves/2.0", params)
        
        return NVDAPIResponse(
            cves=response.get("vulnerabilities", []),
            total_results=response.get("totalResults", 0),
            results_per_page=response.get("resultsPerPage", 0),
            start_index=response.get("startIndex", 0),
            format=response.get("format", "NVD_CVE"),
            version=response.get("version", "2.0"),
            timestamp=datetime.now()
        )
    
    async def search_cves_by_cpe(
        self,
        cpe_name: str,
        results_per_page: int = 100,
        start_index: int = 0
    ) -> NVDAPIResponse:
        """
        Search CVEs by CPE (Common Platform Enumeration)
        
        Args:
            cpe_name: CPE name (e.g., "cpe:2.3:a:vendor:product:version")
            results_per_page: Number of results per page
            start_index: Starting index for pagination
            
        Returns:
            NVD API response with CVE data
        """
        params = {
            "cpeName": cpe_name,
            "resultsPerPage": min(results_per_page, 2000),
            "startIndex": start_index
        }
        
        response = await self._make_request("cves/2.0", params)
        
        return NVDAPIResponse(
            cves=response.get("vulnerabilities", []),
            total_results=response.get("totalResults", 0),
            results_per_page=response.get("resultsPerPage", 0),
            start_index=response.get("startIndex", 0),
            format=response.get("format", "NVD_CVE"),
            version=response.get("version", "2.0"),
            timestamp=datetime.now()
        )
    
    async def get_cve_by_id(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """
        Get specific CVE by ID
        
        Args:
            cve_id: CVE identifier (e.g., "CVE-2023-1234")
            
        Returns:
            CVE data or None if not found
        """
        try:
            response = await self._make_request(f"cves/2.0", {"cveId": cve_id})
            vulnerabilities = response.get("vulnerabilities", [])
            return vulnerabilities[0] if vulnerabilities else None
        except Exception as e:
            logger.error(f"Failed to get CVE {cve_id}: {str(e)}")
            return None
    
    def get_stats(self) -> Dict[str, Any]:
        """Get client statistics"""
        return {
            **self.stats,
            "has_api_key": bool(self.api_key),
            "requests_per_second": self.requests_per_second,
            "cache_size": len(self.cache)
        }


class VulnerabilityScanner:
    """
    Main vulnerability scanner that coordinates CVE lookup and analysis
    
    Features:
    - Package-to-CVE mapping for multiple ecosystems
    - Severity filtering and prioritization
    - Batch processing for efficiency
    - Detailed vulnerability reports
    - False positive reduction
    """
    
    def __init__(self, nvd_client: Optional[NVDAPIClient] = None):
        """
        Initialize vulnerability scanner
        
        Args:
            nvd_client: Optional NVD API client (will create default if None)
        """
        self.nvd_client = nvd_client
        
        # Package ecosystem to CPE vendor mappings
        self.ecosystem_vendors = {
            PackageEcosystem.NPM: "nodejs",
            PackageEcosystem.PIP: "python",
            PackageEcosystem.CARGO: "rust-lang",
            PackageEcosystem.MAVEN: "apache",
            PackageEcosystem.GRADLE: "gradle"
        }
    
    async def __aenter__(self):
        """Async context manager entry"""
        if not self.nvd_client:
            self.nvd_client = NVDAPIClient()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.nvd_client:
            await self.nvd_client.close()
    
    async def scan_dependencies(
        self,
        dependencies: List[ParsedDependency],
        severity_filter: Optional[Set[VulnerabilitySeverity]] = None,
        include_low_confidence: bool = False
    ) -> List[VulnerabilityMatch]:
        """
        Scan list of dependencies for vulnerabilities
        
        Args:
            dependencies: List of parsed dependencies
            severity_filter: Only include vulnerabilities of these severities
            include_low_confidence: Include low-confidence matches
            
        Returns:
            List of vulnerability matches
        """
        if not self.nvd_client:
            self.nvd_client = NVDAPIClient()
        
        # Default to Critical and High severity only
        if severity_filter is None:
            severity_filter = {VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH}
        
        vulnerability_matches = []
        
        # Process dependencies in batches to avoid overwhelming the API
        batch_size = 10
        for i in range(0, len(dependencies), batch_size):
            batch = dependencies[i:i + batch_size]
            
            # Process batch concurrently
            tasks = [
                self._scan_single_dependency(dep, severity_filter, include_low_confidence)
                for dep in batch
            ]
            
            batch_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in batch_results:
                if isinstance(result, Exception):
                    logger.error(f"Error scanning dependency: {str(result)}")
                    continue
                elif result:
                    vulnerability_matches.extend(result)
            
            # Small delay between batches to be nice to the API
            if i + batch_size < len(dependencies):
                await asyncio.sleep(1.0)
        
        return vulnerability_matches
    
    async def _scan_single_dependency(
        self,
        dependency: ParsedDependency,
        severity_filter: Set[VulnerabilitySeverity],
        include_low_confidence: bool
    ) -> List[VulnerabilityMatch]:
        """Scan a single dependency for vulnerabilities"""
        try:
            logger.debug(f"Scanning {dependency.name}@{dependency.version} for vulnerabilities")
            
            # Search for CVEs related to this package
            nvd_response = await self.nvd_client.search_cves_by_keyword(
                keyword=dependency.name,
                results_per_page=50  # Limit results for performance
            )
            
            matches = []
            
            for cve_data in nvd_response.cves:
                cve = cve_data.get("cve", {})
                cve_id = cve.get("id", "")
                
                # Extract vulnerability information
                vulnerability = self._parse_cve_data(cve_data, dependency.name, dependency.version)
                
                # Check if this CVE affects our specific package version
                match_result = self._check_version_affected(
                    dependency, cve_data, vulnerability
                )
                
                if match_result and match_result.confidence_score > 0.0:
                    # Apply severity filter
                    if vulnerability.severity in severity_filter:
                        # Apply confidence filter
                        if include_low_confidence or match_result.confidence_score >= 0.5:
                            matches.append(match_result)
            
            logger.debug(f"Found {len(matches)} vulnerability matches for {dependency.name}")
            return matches
            
        except Exception as e:
            logger.error(f"Error scanning dependency {dependency.name}: {str(e)}")
            return []
    
    def _parse_cve_data(self, cve_data: Dict[str, Any], package_name: str = "", package_version: str = "") -> Any:
        """Parse CVE data into VulnerabilityData model"""
        cve = cve_data.get("cve", {})
        cve_id = cve.get("id", "")
        
        # Extract description
        descriptions = cve.get("descriptions", [])
        description = ""
        for desc in descriptions:
            if desc.get("lang") == "en":
                description = desc.get("value", "")
                break
        
        # Extract CVSS scores
        metrics = cve_data.get("cve", {}).get("metrics", {})
        cvss_score = 0.0
        
        # Try CVSS v3.1 first, then v3.0, then v2.0
        for version in ["cvssMetricV31", "cvssMetricV30", "cvssMetricV2"]:
            if version in metrics and metrics[version]:
                metric = metrics[version][0]  # Take first metric
                cvss_data = metric.get("cvssData", {})
                cvss_score = cvss_data.get("baseScore", 0.0)
                break
        
        # Determine severity - convert to our model's SeverityLevel
        severity_str = self._calculate_severity(cvss_score)
        # Map our internal severity to the model's SeverityLevel
        from ..models import SeverityLevel
        severity_mapping = {
            VulnerabilitySeverity.CRITICAL: SeverityLevel.CRITICAL,
            VulnerabilitySeverity.HIGH: SeverityLevel.HIGH,
            VulnerabilitySeverity.MEDIUM: SeverityLevel.MEDIUM,
            VulnerabilitySeverity.LOW: SeverityLevel.LOW
        }
        severity = severity_mapping.get(severity_str, SeverityLevel.LOW)
        
        # Extract published and modified dates
        published_date_str = cve.get("published")
        modified_date_str = cve.get("lastModified")
        
        # Parse datetime strings
        published_date = None
        modified_date = None
        try:
            if published_date_str:
                published_date = datetime.fromisoformat(published_date_str.replace('Z', '+00:00'))
            if modified_date_str:
                modified_date = datetime.fromisoformat(modified_date_str.replace('Z', '+00:00'))
        except Exception as e:
            logger.warning(f"Failed to parse CVE dates: {str(e)}")
        
        # Create CVE URL
        cve_url = f"https://nvd.nist.gov/vuln/detail/{cve_id}"
        
        # Use the model from our imports
        from ..models import VulnerabilityData as ModelVulnerabilityData
        
        return ModelVulnerabilityData(
            cve_id=cve_id,
            package_name=package_name,
            package_version=package_version,
            description=description,
            severity=severity,
            cvss_score=cvss_score,
            cve_url=cve_url,
            published_date=published_date,
            last_modified=modified_date
        )
    
    def _extract_cwe_ids(self, cve: Dict[str, Any]) -> List[str]:
        """Extract CWE IDs from CVE data"""
        cwe_ids = []
        weaknesses = cve.get("weaknesses", [])
        for weakness in weaknesses:
            descriptions = weakness.get("description", [])
            for desc in descriptions:
                if desc.get("lang") == "en":
                    value = desc.get("value", "")
                    if value.startswith("CWE-"):
                        cwe_ids.append(value)
        return cwe_ids
    
    def _calculate_severity(self, cvss_score: float) -> VulnerabilitySeverity:
        """Calculate severity based on CVSS score"""
        if cvss_score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif cvss_score >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif cvss_score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        elif cvss_score > 0.0:
            return VulnerabilitySeverity.LOW
        elif cvss_score == 0.0:
            return VulnerabilitySeverity.NONE
        else:
            return VulnerabilitySeverity.UNKNOWN
    
    def _check_version_affected(
        self,
        dependency: ParsedDependency,
        cve_data: Dict[str, Any],
        vulnerability: Any
    ) -> Optional[VulnerabilityMatch]:
        """
        Check if a specific package version is affected by a CVE
        
        This is a simplified implementation. In production, you would want
        more sophisticated version matching based on CPE data.
        """
        cve = cve_data.get("cve", {})
        cve_id = cve.get("id", "")
        
        # Basic confidence scoring based on package name matching
        confidence_score = 0.0
        match_method = "keyword_match"
        
        # Check if package name appears in CVE description or references
        description = vulnerability.description.lower()
        package_name_lower = dependency.name.lower()
        
        if package_name_lower in description:
            confidence_score += 0.6
        
        # Check for exact package name matches in description
        if f" {package_name_lower} " in description or description.startswith(package_name_lower):
            confidence_score += 0.3
        
        # Check for version-specific mentions
        if dependency.version != "unknown" and dependency.version in description:
            confidence_score += 0.1
            match_method = "version_specific_match"
        
        # This is a simplified implementation - in production you would:
        # 1. Parse CPE data to get exact package/version mappings
        # 2. Use vulnerability databases with structured affected version ranges
        # 3. Implement proper semantic version comparisons
        
        if confidence_score > 0.0:
            return VulnerabilityMatch(
                cve_id=cve_id,
                package_name=dependency.name,
                package_version=dependency.version,
                vulnerability_data=vulnerability,
                confidence_score=confidence_score,
                match_method=match_method,
                affected_versions=["unknown"],  # Would be parsed from CVE data
                patched_versions=[]  # Would be parsed from advisory data
            )
        
        return None


# Singleton instance for application use
_nvd_client: Optional[NVDAPIClient] = None


async def get_nvd_client() -> NVDAPIClient:
    """Get singleton NVD API client instance"""
    global _nvd_client
    
    if _nvd_client is None:
        _nvd_client = NVDAPIClient()
        logger.info("NVD API client initialized")
    
    return _nvd_client


async def close_nvd_client():
    """Close the global NVD client"""
    global _nvd_client
    
    if _nvd_client:
        await _nvd_client.close()
        _nvd_client = None
        logger.info("NVD API client closed")


async def scan_dependencies_for_vulnerabilities(
    dependencies: List[ParsedDependency],
    severity_filter: Optional[List[str]] = None,
    nvd_client: Optional[NVDAPIClient] = None
) -> List[VulnerabilityMatch]:
    """
    Convenience function to scan dependencies for vulnerabilities
    
    Args:
        dependencies: List of parsed dependencies
        severity_filter: List of severity levels to include
        nvd_client: Optional NVD client
        
    Returns:
        List of vulnerability matches
    """
    # Convert severity filter
    severity_set = None
    if severity_filter:
        severity_set = {VulnerabilitySeverity(s.upper()) for s in severity_filter}
    
    async with VulnerabilityScanner(nvd_client) as scanner:
        return await scanner.scan_dependencies(
            dependencies,
            severity_filter=severity_set,
            include_low_confidence=False
        )
