"""
Vulnerability Data Enrichment with Advanced CVSS Analysis and Impact Details

This module provides comprehensive vulnerability data enrichment by extracting
and analyzing detailed CVSS (Common Vulnerability Scoring System) information
from the National Vulnerability Database (NVD). It enhances basic vulnerability
data with:

- Detailed CVSS v3.1, v3.0, and v2.0 vector analysis
- Attack vector, complexity, and impact assessments
- Exploitability and temporal metrics
- Environmental scoring considerations
- Weakness categorization (CWE mapping)
- Reference links and proof-of-concept information
- Vendor advisory and patch information
"""

import logging
import re
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import json

from ..models import VulnerabilityData, SeverityLevel
from ..utils.exceptions import VulnerabilityServiceError

logger = logging.getLogger(__name__)


class CVSSVersion(str, Enum):
    """CVSS version types"""
    V31 = "3.1"
    V30 = "3.0"
    V2 = "2.0"


class AttackVector(str, Enum):
    """CVSS Attack Vector values"""
    NETWORK = "N"           # Network
    ADJACENT = "A"          # Adjacent Network
    LOCAL = "L"             # Local
    PHYSICAL = "P"          # Physical


class AttackComplexity(str, Enum):
    """CVSS Attack Complexity values"""
    LOW = "L"               # Low
    HIGH = "H"              # High


class PrivilegesRequired(str, Enum):
    """CVSS Privileges Required values"""
    NONE = "N"              # None
    LOW = "L"               # Low
    HIGH = "H"              # High


class UserInteraction(str, Enum):
    """CVSS User Interaction values"""
    NONE = "N"              # None
    REQUIRED = "R"          # Required


class Scope(str, Enum):
    """CVSS Scope values"""
    UNCHANGED = "U"         # Unchanged
    CHANGED = "C"           # Changed


class Impact(str, Enum):
    """CVSS Impact values"""
    NONE = "N"              # None
    LOW = "L"               # Low
    HIGH = "H"              # High


class Exploitability(str, Enum):
    """CVSS Exploitability values"""
    UNPROVEN = "U"          # Unproven
    PROOF_OF_CONCEPT = "P"  # Proof of concept
    FUNCTIONAL = "F"        # Functional
    HIGH = "H"              # High
    NOT_DEFINED = "X"       # Not defined


class RemediationLevel(str, Enum):
    """CVSS Remediation Level values"""
    OFFICIAL_FIX = "O"      # Official fix
    TEMPORARY_FIX = "T"     # Temporary fix
    WORKAROUND = "W"        # Workaround
    UNAVAILABLE = "U"       # Unavailable
    NOT_DEFINED = "X"       # Not defined


class ReportConfidence(str, Enum):
    """CVSS Report Confidence values"""
    UNKNOWN = "U"           # Unknown
    REASONABLE = "R"        # Reasonable
    CONFIRMED = "C"         # Confirmed
    NOT_DEFINED = "X"       # Not defined


@dataclass
class CVSSVector:
    """Parsed CVSS vector components"""
    version: CVSSVersion
    attack_vector: Optional[AttackVector] = None
    attack_complexity: Optional[AttackComplexity] = None
    privileges_required: Optional[PrivilegesRequired] = None
    user_interaction: Optional[UserInteraction] = None
    scope: Optional[Scope] = None
    confidentiality_impact: Optional[Impact] = None
    integrity_impact: Optional[Impact] = None
    availability_impact: Optional[Impact] = None
    
    # Temporal metrics
    exploitability: Optional[Exploitability] = None
    remediation_level: Optional[RemediationLevel] = None
    report_confidence: Optional[ReportConfidence] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            "version": self.version.value,
            "attack_vector": self.attack_vector.value if self.attack_vector else None,
            "attack_complexity": self.attack_complexity.value if self.attack_complexity else None,
            "privileges_required": self.privileges_required.value if self.privileges_required else None,
            "user_interaction": self.user_interaction.value if self.user_interaction else None,
            "scope": self.scope.value if self.scope else None,
            "confidentiality_impact": self.confidentiality_impact.value if self.confidentiality_impact else None,
            "integrity_impact": self.integrity_impact.value if self.integrity_impact else None,
            "availability_impact": self.availability_impact.value if self.availability_impact else None,
            "exploitability": self.exploitability.value if self.exploitability else None,
            "remediation_level": self.remediation_level.value if self.remediation_level else None,
            "report_confidence": self.report_confidence.value if self.report_confidence else None
        }


@dataclass
class CVSSScores:
    """Complete CVSS scoring information"""
    base_score: float = 0.0
    temporal_score: Optional[float] = None
    environmental_score: Optional[float] = None
    
    # Sub-scores
    exploitability_score: Optional[float] = None
    impact_score: Optional[float] = None
    
    # Vector string
    vector_string: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            "base_score": self.base_score,
            "temporal_score": self.temporal_score,
            "environmental_score": self.environmental_score,
            "exploitability_score": self.exploitability_score,
            "impact_score": self.impact_score,
            "vector_string": self.vector_string
        }


@dataclass
class WeaknessInfo:
    """CWE (Common Weakness Enumeration) information"""
    cwe_id: str
    description: str
    source: str = "NVD"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            "cwe_id": self.cwe_id,
            "description": self.description,
            "source": self.source
        }


@dataclass
class ReferenceInfo:
    """External reference information"""
    url: str
    name: Optional[str] = None
    reference_type: Optional[str] = None  # e.g., "Advisory", "Patch", "Exploit"
    tags: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            "url": self.url,
            "name": self.name,
            "reference_type": self.reference_type,
            "tags": self.tags
        }


@dataclass
class EnrichedVulnerabilityData:
    """Enhanced vulnerability data with detailed CVSS and impact analysis"""
    
    # Basic vulnerability info
    cve_id: str
    package_name: str
    package_version: str
    severity: SeverityLevel
    description: str
    cve_url: str
    published_date: Optional[datetime] = None
    last_modified: Optional[datetime] = None
    
    # Enhanced CVSS information
    cvss_v31: Optional[CVSSScores] = None
    cvss_v30: Optional[CVSSScores] = None
    cvss_v2: Optional[CVSSScores] = None
    
    # CVSS vector analysis
    cvss_vector: Optional[CVSSVector] = None
    
    # Weakness information
    weaknesses: List[WeaknessInfo] = field(default_factory=list)
    
    # Reference information
    references: List[ReferenceInfo] = field(default_factory=list)
    
    # Impact analysis
    attack_vector_analysis: Optional[str] = None
    exploitability_assessment: Optional[str] = None
    impact_assessment: Optional[str] = None
    
    # Vendor and patch information
    vendor_advisories: List[str] = field(default_factory=list)
    patch_available: Optional[bool] = None
    patch_urls: List[str] = field(default_factory=list)
    
    def get_primary_cvss_score(self) -> float:
        """Get the primary CVSS score (highest version available)"""
        if self.cvss_v31:
            return self.cvss_v31.base_score
        elif self.cvss_v30:
            return self.cvss_v30.base_score
        elif self.cvss_v2:
            return self.cvss_v2.base_score
        return 0.0
    
    def get_exploitability_rating(self) -> str:
        """Get human-readable exploitability rating"""
        if not self.cvss_vector or not self.cvss_vector.exploitability:
            return "Unknown"
        
        exploitability_map = {
            Exploitability.HIGH: "High - Active exploits available",
            Exploitability.FUNCTIONAL: "Functional - Working exploit exists",
            Exploitability.PROOF_OF_CONCEPT: "Proof of Concept - Theoretical exploit",
            Exploitability.UNPROVEN: "Unproven - No known exploits",
            Exploitability.NOT_DEFINED: "Not Defined"
        }
        return exploitability_map.get(self.cvss_vector.exploitability, "Unknown")
    
    def get_attack_vector_description(self) -> str:
        """Get human-readable attack vector description"""
        if not self.cvss_vector or not self.cvss_vector.attack_vector:
            return "Unknown"
        
        vector_descriptions = {
            AttackVector.NETWORK: "Network - Remotely exploitable",
            AttackVector.ADJACENT: "Adjacent Network - Local network required", 
            AttackVector.LOCAL: "Local - Local access required",
            AttackVector.PHYSICAL: "Physical - Physical access required"
        }
        return vector_descriptions.get(self.cvss_vector.attack_vector, "Unknown")
    
    def get_impact_summary(self) -> Dict[str, str]:
        """Get summary of confidentiality, integrity, and availability impacts"""
        if not self.cvss_vector:
            return {"confidentiality": "Unknown", "integrity": "Unknown", "availability": "Unknown"}
        
        impact_map = {
            Impact.HIGH: "High",
            Impact.LOW: "Low", 
            Impact.NONE: "None"
        }
        
        return {
            "confidentiality": impact_map.get(self.cvss_vector.confidentiality_impact, "Unknown"),
            "integrity": impact_map.get(self.cvss_vector.integrity_impact, "Unknown"),
            "availability": impact_map.get(self.cvss_vector.availability_impact, "Unknown")
        }
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API responses"""
        return {
            "cve_id": self.cve_id,
            "package_name": self.package_name,
            "package_version": self.package_version,
            "severity": self.severity.value,
            "description": self.description,
            "cve_url": self.cve_url,
            "published_date": self.published_date.isoformat() if self.published_date else None,
            "last_modified": self.last_modified.isoformat() if self.last_modified else None,
            "primary_cvss_score": self.get_primary_cvss_score(),
            "cvss_scores": {
                "v3.1": self.cvss_v31.to_dict() if self.cvss_v31 else None,
                "v3.0": self.cvss_v30.to_dict() if self.cvss_v30 else None,
                "v2.0": self.cvss_v2.to_dict() if self.cvss_v2 else None
            },
            "cvss_vector": self.cvss_vector.to_dict() if self.cvss_vector else None,
            "weaknesses": [w.to_dict() for w in self.weaknesses],
            "references": [r.to_dict() for r in self.references],
            "attack_vector_analysis": self.attack_vector_analysis,
            "exploitability_assessment": self.exploitability_assessment,
            "impact_assessment": self.impact_assessment,
            "exploitability_rating": self.get_exploitability_rating(),
            "attack_vector_description": self.get_attack_vector_description(),
            "impact_summary": self.get_impact_summary(),
            "vendor_advisories": self.vendor_advisories,
            "patch_available": self.patch_available,
            "patch_urls": self.patch_urls
        }


class VulnerabilityEnricher:
    """
    Service for enriching vulnerability data with detailed CVSS analysis and impact information
    """
    
    def __init__(self):
        """Initialize vulnerability enricher"""
        self.stats = {
            "enrichments_performed": 0,
            "cvss_vectors_parsed": 0,
            "weaknesses_extracted": 0,
            "references_processed": 0,
            "errors": 0
        }
    
    def enrich_vulnerability(
        self,
        base_vulnerability: VulnerabilityData,
        nvd_cve_data: Dict[str, Any]
    ) -> EnrichedVulnerabilityData:
        """
        Enrich basic vulnerability data with detailed CVSS and impact information
        
        Args:
            base_vulnerability: Basic vulnerability data
            nvd_cve_data: Full CVE data from NVD API
            
        Returns:
            Enriched vulnerability data with detailed analysis
        """
        try:
            self.stats["enrichments_performed"] += 1
            
            # Create enriched vulnerability with base data
            enriched = EnrichedVulnerabilityData(
                cve_id=base_vulnerability.cve_id,
                package_name=base_vulnerability.package_name,
                package_version=base_vulnerability.package_version,
                severity=base_vulnerability.severity,
                description=base_vulnerability.description,
                cve_url=base_vulnerability.cve_url,
                published_date=base_vulnerability.published_date,
                last_modified=base_vulnerability.last_modified
            )
            
            cve = nvd_cve_data.get("cve", {})
            
            # Extract CVSS scores and vectors
            enriched.cvss_v31, enriched.cvss_v30, enriched.cvss_v2 = self._extract_cvss_scores(cve)
            enriched.cvss_vector = self._parse_cvss_vector(cve)
            if enriched.cvss_vector:
                self.stats["cvss_vectors_parsed"] += 1
            
            # Extract weakness information
            enriched.weaknesses = self._extract_weaknesses(cve)
            self.stats["weaknesses_extracted"] += len(enriched.weaknesses)
            
            # Extract reference information
            enriched.references = self._extract_references(cve)
            self.stats["references_processed"] += len(enriched.references)
            
            # Generate impact assessments
            enriched.attack_vector_analysis = self._analyze_attack_vector(enriched.cvss_vector)
            enriched.exploitability_assessment = self._assess_exploitability(enriched.cvss_vector, enriched.references)
            enriched.impact_assessment = self._assess_impact(enriched.cvss_vector)
            
            # Extract vendor and patch information
            enriched.vendor_advisories, enriched.patch_urls = self._extract_vendor_info(enriched.references)
            enriched.patch_available = len(enriched.patch_urls) > 0
            
            return enriched
            
        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Error enriching vulnerability {base_vulnerability.cve_id}: {str(e)}")
            raise VulnerabilityServiceError(
                f"Failed to enrich vulnerability data: {str(e)}",
                service="VulnerabilityEnricher"
            )
    
    def _extract_cvss_scores(self, cve: Dict[str, Any]) -> Tuple[Optional[CVSSScores], Optional[CVSSScores], Optional[CVSSScores]]:
        """Extract CVSS scores for all available versions"""
        metrics = cve.get("metrics", {})
        
        cvss_v31 = None
        cvss_v30 = None
        cvss_v2 = None
        
        # Extract CVSS v3.1
        if "cvssMetricV31" in metrics and metrics["cvssMetricV31"]:
            metric = metrics["cvssMetricV31"][0]
            cvss_data = metric.get("cvssData", {})
            cvss_v31 = CVSSScores(
                base_score=cvss_data.get("baseScore", 0.0),
                temporal_score=cvss_data.get("temporalScore"),
                environmental_score=cvss_data.get("environmentalScore"),
                exploitability_score=cvss_data.get("exploitabilityScore"),
                impact_score=cvss_data.get("impactScore"),
                vector_string=cvss_data.get("vectorString")
            )
        
        # Extract CVSS v3.0
        if "cvssMetricV30" in metrics and metrics["cvssMetricV30"]:
            metric = metrics["cvssMetricV30"][0]
            cvss_data = metric.get("cvssData", {})
            cvss_v30 = CVSSScores(
                base_score=cvss_data.get("baseScore", 0.0),
                temporal_score=cvss_data.get("temporalScore"),
                environmental_score=cvss_data.get("environmentalScore"),
                exploitability_score=cvss_data.get("exploitabilityScore"),
                impact_score=cvss_data.get("impactScore"),
                vector_string=cvss_data.get("vectorString")
            )
        
        # Extract CVSS v2
        if "cvssMetricV2" in metrics and metrics["cvssMetricV2"]:
            metric = metrics["cvssMetricV2"][0]
            cvss_data = metric.get("cvssData", {})
            cvss_v2 = CVSSScores(
                base_score=cvss_data.get("baseScore", 0.0),
                temporal_score=cvss_data.get("temporalScore"),
                environmental_score=cvss_data.get("environmentalScore"),
                vector_string=cvss_data.get("vectorString")
            )
        
        return cvss_v31, cvss_v30, cvss_v2
    
    def _parse_cvss_vector(self, cve: Dict[str, Any]) -> Optional[CVSSVector]:
        """Parse CVSS vector string into components"""
        metrics = cve.get("metrics", {})
        
        # Try to get vector string from v3.1, then v3.0, then v2
        vector_string = None
        version = None
        
        for version_key, cvss_version in [("cvssMetricV31", CVSSVersion.V31), 
                                         ("cvssMetricV30", CVSSVersion.V30),
                                         ("cvssMetricV2", CVSSVersion.V2)]:
            if version_key in metrics and metrics[version_key]:
                metric = metrics[version_key][0]
                cvss_data = metric.get("cvssData", {})
                vector_string = cvss_data.get("vectorString")
                if vector_string:
                    version = cvss_version
                    break
        
        if not vector_string or not version:
            return None
        
        return self._parse_vector_string(vector_string, version)
    
    def _parse_vector_string(self, vector_string: str, version: CVSSVersion) -> Optional[CVSSVector]:
        """Parse CVSS vector string into components"""
        try:
            vector = CVSSVector(version=version)
            
            # Parse vector components
            components = vector_string.split('/')
            
            for component in components:
                if ':' not in component:
                    continue
                
                key, value = component.split(':', 1)
                
                # Map CVSS v3.x components
                if version in [CVSSVersion.V31, CVSSVersion.V30]:
                    if key == "AV":  # Attack Vector
                        vector.attack_vector = AttackVector(value)
                    elif key == "AC":  # Attack Complexity
                        vector.attack_complexity = AttackComplexity(value)
                    elif key == "PR":  # Privileges Required
                        vector.privileges_required = PrivilegesRequired(value)
                    elif key == "UI":  # User Interaction
                        vector.user_interaction = UserInteraction(value)
                    elif key == "S":   # Scope
                        vector.scope = Scope(value)
                    elif key == "C":   # Confidentiality Impact
                        vector.confidentiality_impact = Impact(value)
                    elif key == "I":   # Integrity Impact
                        vector.integrity_impact = Impact(value)
                    elif key == "A":   # Availability Impact
                        vector.availability_impact = Impact(value)
                    elif key == "E":   # Exploitability
                        vector.exploitability = Exploitability(value)
                    elif key == "RL":  # Remediation Level
                        vector.remediation_level = RemediationLevel(value)
                    elif key == "RC":  # Report Confidence
                        vector.report_confidence = ReportConfidence(value)
                
                # Handle CVSS v2 components (simplified)
                elif version == CVSSVersion.V2:
                    if key == "AV":
                        # Map v2 values to v3 equivalents
                        v2_to_v3 = {"L": "L", "A": "A", "N": "N"}
                        if value in v2_to_v3:
                            vector.attack_vector = AttackVector(v2_to_v3[value])
            
            return vector
            
        except Exception as e:
            logger.warning(f"Failed to parse CVSS vector '{vector_string}': {str(e)}")
            return None
    
    def _extract_weaknesses(self, cve: Dict[str, Any]) -> List[WeaknessInfo]:
        """Extract CWE weakness information"""
        weaknesses = []
        
        weakness_data = cve.get("weaknesses", [])
        for weakness in weakness_data:
            descriptions = weakness.get("description", [])
            for desc in descriptions:
                if desc.get("lang") == "en":
                    value = desc.get("value", "")
                    if value.startswith("CWE-"):
                        weaknesses.append(WeaknessInfo(
                            cwe_id=value,
                            description=self._get_cwe_description(value),
                            source=weakness.get("source", "NVD")
                        ))
        
        return weaknesses
    
    def _extract_references(self, cve: Dict[str, Any]) -> List[ReferenceInfo]:
        """Extract reference information and categorize by type"""
        references = []
        
        reference_data = cve.get("references", [])
        for ref in reference_data:
            url = ref.get("url", "")
            name = ref.get("name")
            tags = ref.get("tags", [])
            
            # Determine reference type based on URL and tags
            ref_type = self._categorize_reference(url, tags)
            
            references.append(ReferenceInfo(
                url=url,
                name=name,
                reference_type=ref_type,
                tags=tags
            ))
        
        return references
    
    def _categorize_reference(self, url: str, tags: List[str]) -> Optional[str]:
        """Categorize reference by type"""
        url_lower = url.lower()
        
        # Check tags first
        for tag in tags:
            tag_lower = tag.lower()
            if "patch" in tag_lower:
                return "Patch"
            elif "advisory" in tag_lower:
                return "Advisory" 
            elif "exploit" in tag_lower:
                return "Exploit"
            elif "vendor" in tag_lower:
                return "Vendor Advisory"
        
        # Check URL patterns
        if any(domain in url_lower for domain in ["github.com", "gitlab.com"]):
            if "/commit/" in url_lower or "/pull/" in url_lower:
                return "Patch"
            elif "/issues/" in url_lower:
                return "Issue Report"
        elif "security" in url_lower or "advisory" in url_lower:
            return "Security Advisory"
        elif "exploit" in url_lower or "poc" in url_lower:
            return "Exploit"
        elif any(domain in url_lower for domain in ["nvd.nist.gov", "cve.mitre.org"]):
            return "CVE Database"
        
        return "General Reference"
    
    def _get_cwe_description(self, cwe_id: str) -> str:
        """Get human-readable description for CWE ID"""
        # Common CWE descriptions (in production, this could be loaded from a database)
        cwe_descriptions = {
            "CWE-79": "Cross-site Scripting (XSS)",
            "CWE-89": "SQL Injection",
            "CWE-22": "Path Traversal",
            "CWE-352": "Cross-Site Request Forgery (CSRF)",
            "CWE-78": "OS Command Injection",
            "CWE-94": "Code Injection",
            "CWE-502": "Deserialization of Untrusted Data",
            "CWE-287": "Authentication Bypass",
            "CWE-285": "Authorization Issues",
            "CWE-798": "Hard-coded Credentials",
            "CWE-200": "Information Exposure",
            "CWE-611": "XML External Entity (XXE)",
            "CWE-434": "Unrestricted File Upload",
            "CWE-295": "Certificate Validation Issues",
            "CWE-119": "Buffer Overflow"
        }
        
        return cwe_descriptions.get(cwe_id, f"Common Weakness Enumeration {cwe_id}")
    
    def _analyze_attack_vector(self, cvss_vector: Optional[CVSSVector]) -> Optional[str]:
        """Generate attack vector analysis"""
        if not cvss_vector or not cvss_vector.attack_vector:
            return None
        
        analyses = {
            AttackVector.NETWORK: "This vulnerability can be exploited remotely over a network connection, making it highly dangerous as attackers do not need physical or local access.",
            AttackVector.ADJACENT: "This vulnerability requires the attacker to be on the same network segment (e.g., local area network), limiting the attack scope but still allowing remote exploitation within the network.",
            AttackVector.LOCAL: "This vulnerability requires local access to the target system, limiting exploitation to users who already have access to the machine.",
            AttackVector.PHYSICAL: "This vulnerability requires physical access to the target system, significantly limiting the attack surface to scenarios where an attacker has physical proximity."
        }
        
        return analyses.get(cvss_vector.attack_vector)
    
    def _assess_exploitability(self, cvss_vector: Optional[CVSSVector], references: List[ReferenceInfo]) -> Optional[str]:
        """Assess exploitability based on CVSS and available exploits"""
        if not cvss_vector:
            return None
        
        # Check for exploit references
        exploit_refs = [r for r in references if r.reference_type == "Exploit"]
        has_exploits = len(exploit_refs) > 0
        
        # Base exploitability assessment
        if cvss_vector.exploitability:
            if cvss_vector.exploitability == Exploitability.HIGH:
                return "HIGH RISK: Active exploits are available and being used in the wild. Immediate patching is critical."
            elif cvss_vector.exploitability == Exploitability.FUNCTIONAL:
                return "MEDIUM-HIGH RISK: Functional exploit code exists. This vulnerability is likely to be exploited."
            elif cvss_vector.exploitability == Exploitability.PROOF_OF_CONCEPT:
                return "MEDIUM RISK: Proof-of-concept exploit exists. Attack code could be developed into working exploits."
            elif cvss_vector.exploitability == Exploitability.UNPROVEN:
                return "LOW-MEDIUM RISK: No proven exploits exist, but the vulnerability could still be exploited with sufficient research."
        
        # Fallback assessment based on other factors
        if has_exploits:
            return "MEDIUM-HIGH RISK: Exploit code or proof-of-concept is publicly available."
        elif cvss_vector.attack_vector == AttackVector.NETWORK and cvss_vector.attack_complexity == AttackComplexity.LOW:
            return "MEDIUM RISK: Network-accessible with low attack complexity. Could be exploited with moderate effort."
        
        return "LOW-MEDIUM RISK: Limited exploitability based on available information."
    
    def _assess_impact(self, cvss_vector: Optional[CVSSVector]) -> Optional[str]:
        """Assess impact based on CVSS vector"""
        if not cvss_vector:
            return None
        
        impacts = []
        
        # Confidentiality impact
        if cvss_vector.confidentiality_impact == Impact.HIGH:
            impacts.append("Complete loss of confidentiality - all data may be disclosed")
        elif cvss_vector.confidentiality_impact == Impact.LOW:
            impacts.append("Partial confidentiality loss - some sensitive data may be disclosed")
        
        # Integrity impact
        if cvss_vector.integrity_impact == Impact.HIGH:
            impacts.append("Complete loss of integrity - all data may be modified")
        elif cvss_vector.integrity_impact == Impact.LOW:
            impacts.append("Partial integrity loss - some data may be modified")
        
        # Availability impact
        if cvss_vector.availability_impact == Impact.HIGH:
            impacts.append("Complete loss of availability - system may become completely unusable")
        elif cvss_vector.availability_impact == Impact.LOW:
            impacts.append("Partial availability loss - system performance may be degraded")
        
        if not impacts:
            return "No significant impact on confidentiality, integrity, or availability."
        
        return "; ".join(impacts) + "."
    
    def _extract_vendor_info(self, references: List[ReferenceInfo]) -> Tuple[List[str], List[str]]:
        """Extract vendor advisory and patch information"""
        vendor_advisories = []
        patch_urls = []
        
        for ref in references:
            if ref.reference_type in ["Vendor Advisory", "Advisory"]:
                vendor_advisories.append(ref.url)
            elif ref.reference_type == "Patch":
                patch_urls.append(ref.url)
        
        return vendor_advisories, patch_urls
    
    def get_stats(self) -> Dict[str, Any]:
        """Get enrichment statistics"""
        return dict(self.stats)


# Convenience functions for easy integration

def enrich_vulnerability_data(
    base_vulnerability: VulnerabilityData,
    nvd_cve_data: Dict[str, Any]
) -> EnrichedVulnerabilityData:
    """
    Convenience function to enrich vulnerability data
    
    Args:
        base_vulnerability: Basic vulnerability data
        nvd_cve_data: Full CVE data from NVD API
        
    Returns:
        Enriched vulnerability data
    """
    enricher = VulnerabilityEnricher()
    return enricher.enrich_vulnerability(base_vulnerability, nvd_cve_data)


def enrich_vulnerabilities_batch(
    vulnerabilities: List[Tuple[VulnerabilityData, Dict[str, Any]]]
) -> List[EnrichedVulnerabilityData]:
    """
    Convenience function to enrich multiple vulnerabilities
    
    Args:
        vulnerabilities: List of (base_vulnerability, nvd_cve_data) tuples
        
    Returns:
        List of enriched vulnerability data
    """
    enricher = VulnerabilityEnricher()
    enriched_vulns = []
    
    for base_vuln, nvd_data in vulnerabilities:
        try:
            enriched = enricher.enrich_vulnerability(base_vuln, nvd_data)
            enriched_vulns.append(enriched)
        except Exception as e:
            logger.error(f"Failed to enrich {base_vuln.cve_id}: {str(e)}")
            continue
    
    return enriched_vulns
